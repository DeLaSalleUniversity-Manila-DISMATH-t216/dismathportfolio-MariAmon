# dismathportfolio-MariChristineAmon-SectionEL
dismathportfolio-MariAmon created by Classroom for GitHub
<H1>Week 1</H1>
<UL>
<LI>I was introduced to the subject-Dismath-which is about logic using mathematical proof.</LI>
<LI>Proposition and the process of logical deduction are presented to me.</LI>
<LI>Logical connectives-in terms of symbols-are introduced </LI>
<LI>I learned how to use truth tables in determining truth value of propositions.</LI>
<LI>I learned of the contrapositive, inverse and converse of a conditional statement p → q,which is ¬q → ¬p, ¬p → ¬q and q → p,respectively.</LI>
</UL>
<br>
<H1>Week 2</H1>
<UL>
<LI>I learned the logical equivalences and performed logical induction in proving these laws.</LI>
<LI>Propositional logic was introduced-presenting its internal structure:subject and predicate logic.</LI>
<LI>Truth value is classified into two: existential and universal, and are presented using quantifiers.</LI>
<LI>I learned the difference between validity-correct reasoning in terms of pattern(opposite of fallacy) and truth value of the proposition.</LI>
<LI>I learned the use of rules of inference in analyzing and determining truth value of english statements.</LI>
</UL>
#Week 3
<UL>
<LI>I learned how to prove statements using the rules of inference.</LI>
<LI>The proof that Superman doesn't exist was presented in class.</LI>
<LI>I learned the different methods of proof:direct proof, proof by contraposition, as well as, vacuous and trivial proof.</LI>
<LI>Examples and activities are presented to show application of each method of proof.</LI>
</UL>
#Week 4
<UL>
<LI>The methods of vacuous and of trivial proof are further explained to clarify their difference.</LI>
<LI>The method of proof by contradiction, which I think is the trickiest method of all, was then presented.</LI>
<LI>I almost forgot about EngAlg2 until Mathematical Induction was reinforced to the class. </LI>
<LI>In performing mathematical method, one must always follow the properprocedure which is to perform basis stap first before proceeding to the main process.</LI>
<LI>Recursive statements are introduced.</LI>
</UL>
#Week 5
<UL>
<LI>Recursive Algorithm, being discussed, is a step by step process of reducing a problem to an instance of the same problem with smaller input.</LI>
<LI>Programs of factorial and of power rule were presented as examples of recursive algorithm.</LI>
<LI>Program Verification was discussed and how to present proof of correctness of programs with the use of rules of inference.</LI>
<LI>A program is only considered correct if it produces correct output for every possible input.</LI>
<LI>To prove correctness of a program, one must (1)Show Partial Correctness of program and (2) Show that program always terminates.</LI>
<LI>Partial correctness can be done through the use of Hoare Triple, p{s}q, wherein we assume that p is true, then we substitute p to s to show/prove truth value of q.</LI>
<LI>Program correctness can also be proven through the rules of inference: Composition rule, conditional statement and if-else statement.</LI>
<LI>Zeno's Paradox and Power Series were introduced.</LI>
<LI>The formulation of the summation of power series or the Geometric Progression was taught.>
  <UL><LI>summation of ax^n=a1/(1-r)</LI></UL>  </LI
<LI>Set, as then discussed, is an unordered collection of distinct objects.</LI>
<LI>Sets can be presented using Set builder Notation.
  <UL><LI>{x|some property x satisies}</LI></UL>  </LI>
<LI>There are different relationship between sets.
<UL><LI>Union(or)</LI><LI>Intersection(and)</LI><LI>Difference</LI><LI>Symmetric Difference</LI></UL>
</UL>
<LI>I learned that if all elements of Set A are found in B, then set A is a subset of B.</LI>
</UL>
#Week 6
<UL>
<LI>Cardinality was discussed which is is a measure of the number of elements of the set denoted by {A}.</LI>
<LI>Functions was introduced. This is relationship between a set of inputs and a set of permissible outputs given that each input is has exactly one output.</LI>
<LI>I learned the difference between the range-the set of outputs, and the codomain-the set of all possible outputs, of a function.</LI>
<LI>Different types of Functions:
<UL>
<LI>One-To-One Function
<BR>If and only if f(a)=f(b) implies that a=b for all a and b in the domain of f.</LI>
<LI>Onto Function<
<BR>If the range and domain are equal and that every member of the codomain is the image of some element of the domain.</LI>
<LI>Bijection
If it is both one-to-one and onto.</LI>
</UL>
</LI>
</UL>
#Week 7
No classes
#Week 8
<UL>
<LI>We discussed Algorithms which is a set of rules to be followed in problem-solving by a computer.</LI>
<LI>Pseudocodes are a high-level desciprtion of an algorithm that uses structural convention of a programming language, but is intended for human reading.</LI>
<LI>Properties of a psuedocode: Input and Output (or result)</LI>
<LI>There are two procedure in searching the location of an element discussed:
<BR>input: { A1, A2, ..., An }
<BR>output: index { found: {1, ..., n} ; else: -1 }
<UL><LI>Linear Search-one by one search</LI>
<LI>Binary Search-(precondition: elements are in increasing order); continuously divides the set into two and compare them until the first and last element is the same; then compares equaliy between the last element and the actual number being located.</LI></UL>
</LI>
</UL>
#Week 9
<UL>
<LI>Sorting-arranging elements of a list in increasing order</LI>
<LI>There are two types of sorting algorithms:
<UL><LI>Bubble Sort-the highest value element bubbles up the list; this algorithm uses two for-loops that compares an element with the rest of the elements/numbers.</LI>
<LI>Insertion Sort-first element is always considered sorted; this algorithn places an element in order by comparing and inserting it into the already sorted elements of the set.</LI></UL>
</LI>
<LI>Greedy Algorithm in obtaining the least number of coins as change was introduced.</LI> 
<LI>Greedy Algorithm works by providing a set of denomination arranged in increasing order. The program continuously divides the entered value(amount of money) by the first element in the list until it can no longer do so, and that will be the time that the program shall proceed to the next element in the denomination list.</LI> 
</UL>
#Week 10
<UL>
<LI>Growth of Function is an approximation or a limit of a given function; also known as Big-O notation (upper-boundary).</LI>
<LI>Big-O Notation: |f(x)| <= C|g(x)| whenever x>k , C and k are called 'witnesses'</LI>
<LI>Other kinds of approximations are: <BR>Big-Omega Notation (lower-boundary): C|g(x)| <= |f(x)| whenverr x>k. <BR> Big-Theta Notation (both upper and lower boundary): C|g(x)| <= |f(x)| <= C|g(x)|. </LI>
<LI>Big-Theta Notation is also described as Time Complexity of a program or the nummber of comparisons made.</LI>
<LI>Complexity of Algorithms (from lowest to highest)
<UL><LI>Constant Complexity</LI>
    <LI>Logarithm Complexity</LI>
    <LI>Linear Complexity</LI>
    <LI>n log n Complexity</LI>
    <LI>Polynomial Complexity</LI>
    <LI>Exponential Complexity</LI>
    <LI>Factorial Complexity</LI></UL></LI>
<LI>Cryptology is the study of secret messages.<BR>ex. Ceasar Cipher: f(p) = (p+3) mod 26</LI>
</UL>
#Week 11
* No Classes

#Week 12
* Graph Theory is introduced. It is a structure that consists of vertices and edges; connection.
* Degree-(of a vertex) number of edges incident with it. *loop-is counted as degree 2.
* Handshaking Theorem: 2e = Sum[deg(v)] where e is the total number of edges in the graph.
* subgraph - a section that is part of a bigger graph; proper subgraph - a subgraph that is not equal to its 'mother' graph.
* A graph is called connected if there are no isolated nodes.
* Two types of walk: closed - forms a circuit ; open - forms a path. 
* Euler Circuit is a (closed) walk wherein it covers all edges exactly once and goes back to the vertex where it started; exists whenever every vertex in the graph has even degree.
* Euler Path is a (open) walk where all edges are covered once; exists whenever there are exactly two vertices with odd degree.
* Hamilton Circuit a (closed) walk where all nodes are covered once.
* Hamilton path an open walk where all nodes are covered.
* A good example of a Hamilton circuit and path is a dodecahedrom.
* Pendant is a one degree node; whenever one appears a graph, a circuit will never be formed; whenever three appears, there can neither be a path nor a circuit.
* Adjacency Matrix - to put a graph into a matrix by identifying presence of an edge between vertices (denotation: 1 / 0)
* Incidence Matrix - matrix between edges and vertices 
* Isomorphism equivalence betwween two graphs 
* Two graphs are isomorphic whenever:
   - equal nodes amd edges
   - one-to-one correspondence between vertices of the two graphs
* Planar graph is a graph where no edges intersect.
* Euler Formula: r = e - v + 2, where r is the number of regions formed by a graph.
* Kuratowski's Theorem states that a graph is non-planar if and only if it contains a subgraph homeomorphic to K(3,3) and K(5).

#Week 13
* Elementary subdivisions - a planar graph will always obtain a planar graph even when a node or an edge is removed and reconnected with a new element. 
* Homeomorphic graphs are graphs that can be obtained from the same graph by a sequence of elementary subdivisions.
   - ex. Petersen graph is homeomorphic to K(3,3).
* An application of graphs used in coloring maps is the Color Graph; it is the assigment of a color to each vertex so that no two adjacent vertices are assigned to the same color.
* Four Color Theorem states that the chromatic number (or the least number of colors to be used) of a planar graph is no more than 4. 
* A cycle with odd number of vertices has a chromatic number of 3; while, a cycle with even nuumber of vertices has chromatic number of 2.
* Tree is a connected undirected graph with no simple circuit. Its nodes can be classified as parent and children or roots and leaves.
* Rooted root is a tree where the structure starts with a single node called root and every edge is directed away from it.
* M-ary tree is a kind of rooted tree where every internal vertex has no more than m children and is considered "full" (m-ary tree) if every internal vertex has equal number of children.
* Ordered rooted tree is a rooted tree where the children of each vertex are arranged in increasing order from left to right.
* Language and Grammars were introduced in the final meeting. 
* Grammar generates words and identifies whether a word is from a certain language.
* In Formal languages such as Java and C, the grammar or the syntax is vital, and not the meaning or the semantics.
* Syntax is the form of a formal language. A derivation tree may be used to check validity of the grammar.
* Automata theory studies the laws of computation.
* Finite Automaton provides the simplest model of computing device, based on the concept of states.
* Lexical analysis is the process where the stream of characters making up the source program is read from left to right and grouped into tokens.
* Finite-state machine: M = {S, I, O, f, g, s(0)} with S-states, I-input, O-output, f-function, g-function output and s(0)-initial state.

#Additional readings
* Tree traversal is to visit every vertex of an ordered rooted tree.
* Spanning tree - subgraph of simple graph G that is a tree containing every vertex of G.
* A simple graph is connected iff it has a spanning tree.
* Minimum spanning tree - spanning tree that has the smallest possible sum of weights of its edges.
* Relations - relationship of elements between two sets.
* Binary relation from A to B is a subset of A x B.
* Reflexive relation - if (a,a) is an element of R (relation) for every element a in set A.
* Symmetric relation - if (b,a) is an element of R whenever (a,b) is an element of R, for all a,b in set A; antisymmetric - if a = b.
* Transitive relation- whenever (a,b) and (b,c) are elements of R, then (a.c) is an element of R; a,b,c are in set A.
* Composite (S o R) - (a,b) and (b,c) such that (a,c), from sets A, B, C.
* n-ary relation - relationship of elements from more than two sets; A1 x A2 x An where A - domains and n - degree. 
* Equivalence relation - a relation that is reflexive, symmetric and transitive.
* Equivalencee class (of a) - set of all elements that are related to an element a of A.
* Partial ordering - A reflective, antisymmetric and transitive relation on a set S; poset - partially ordered set.
* Lexicographic order - based in the ordering of the letters in the alphabet
* Lattices - a partially unordered set in which every pair of elements has both a least upper bound and a greatest lower bound.
